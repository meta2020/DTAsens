---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# DTAsens

<!-- badges: start -->
<!-- badges: end -->

The goal of DTAsens is to conduct sensitivity analysis on DTA meta-analysis

## Installation

You can install the released version of DTAsens from [GitHub](https://github.com/meta2020/DTAsens) with:

``` r
devtools::install_git("meta2020/DTAsens")
```

## Example

This is a basic example which shows you how to solve a common problem:

```{r}
library(DTAsens)
## basic example code
```

### Example data 1

```{r}

data(dta)
head(dta)

```

### Optim 1

For a certain selection probability, e.g., p = 0.5

```{r}
optim1(dta, p = 0.5)

optim1(dta, p = 0.5, p.hat = TRUE, auc.all = TRUE, show.data = TRUE)
```

For a series of selection probabilities, e.g., p = 0.9, 0,8, ...,0.1


```{r}
p.seq <- seq(0.9, 0.4, -0.1)

estimates <- sapply(p.seq, function(p) optim2(dta, p)$par)
colnames(estimates)<- paste0("p = ", p.seq)
estimates
```

### Optim 2, estimate contrast

For a certain selection probability, e.g., p = 0.5

```{r}

optim2(dta, p = 0.5)

optim2(dta, p = 0.5, p.hat = TRUE, auc.all = TRUE, show.data = TRUE)

```

For a series of selection probabilities, e.g., p = 0.9, 0.8, ...,0.1


```{r}
p.seq <- seq(0.9, 0.4, -0.1)

estimates <- sapply(p.seq, function(p) optim2(dta, p)$par)
colnames(estimates)<- paste0("p = ", p.seq)
estimates
```

### Example data 2 

```{r}
library(mada)
data("AuditC")

head(AuditC)

reitsma(AuditC)
optim1(AuditC, 0.7)
optim2(AuditC, 0.7)

```

### Plot ROC

One ROC

```{r, fig.height=5, fig.width=5}
fit <- reitsma(AuditC)
par0 <- c(fit$coefficients[1], -fit$coefficients[2], fit$vcov[4], -fit$vcov[3])
par1 <- optim1(AuditC, 0.7)$par[c(1,2,4,5)]
par2 <- optim2(AuditC, 0.7)$par[c(1,2,4,5)]

sROC(par = par1, pch = 19)
sROC(par = par2, add = TRUE, col=2, pch = 19)
sROC(par = par0, add = TRUE, col=2, pch = 1, lty =3)

with(AuditC, points(FP/(FP+TN), TP/(TP+FN)))
legend("bottomright", c("optim1", "optim2", "reitsma"), col = c(1,2,2), lty = c(1,1,3), pch = c(19,19,1))
```

A series of ROC

```{r, fig.height=5, fig.width=10}

p.seq <- seq(0.9, 0.1, -0.1)
estimates1 <- sapply(p.seq, function(p) optim1(AuditC, p)$par)[c(1,2,4,5),]
estimates2 <- sapply(p.seq, function(p) optim2(AuditC, p)$par)[c(1,2,4,5),]

par(mfrow = c(1,2))
sROC.bunch(par.matrix = estimates1, p.vec  = p.seq)
sROC(par = par0, add = TRUE, col =2, pch = 1, lty =3)

title("optim1")
sROC.bunch(par.matrix = estimates2, p.vec = p.seq)
sROC(par = par0, add = TRUE, col = 2, pch = 1, lty =3)

title("optim2")
par(mfrow = c(1,1))


```

