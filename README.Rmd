---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%")

options(knitr.kable.NA = '.', digits = 3)
```

# DTA-META-SA

<!-- badges: start -->
<!-- badges: end -->

The goal of `dtametasa` is to conduct sensitivity analysis on the publication bias of meta-analysis of diagnostic test accuracy

## Installation

You can install the released version from [GitHub](https://github.com/meta2020/dtametasa) with:

``` r

# install.packages("devtools")
devtools::install_github("meta2020/dtametasa")

```
## Data Format

Two formats of data are applicable:

- Number of TP/FN/FP/TN

- After logit transformation: y1/y2/v1/v2

<span style="color:red">**Attention: the column names of data must be either of the above.**</span>


## Example

This is an example which shows you how to solve a common problem. 

To take the data `IVD` as example, print the first several lines of data. 

```{r}
## Load package

library(dtametasa)

## Load data

data(IVD)
kable(head(IVD))


data(IVD2)
kable(head(IVD2))
```

### Main function 1: dtametasa.fc

This function need to pre-specify the c contrast in the selection function. 

##### 1. Given a certain selection probability $p$, say, $p = 0.7$, we can get the estimation as follows.


```{r}
## Use default parameters setting
## Print parameters' estimates

(sa1 <- dtametasa.fc(IVD, p = 0.7))

## If we change b.interval

(sa1 <- dtametasa.fc(IVD, p = 0.7, b.interval = c(0, 5)))

## Use str() to get full results list

# str(sa1)

```

##### 2. Given a series of selection probabilities, say, $p = 1, 0.9, 0,8, ...,0.1$. 

Attention: **$p$ must greater than 0 and cannot equal to 0. ($p>0$).**


```{r}

## Set p vectors

p.seq <- seq(1, 0.1, -0.1)

## Get estimations for each p in p.seq vector

est1 <- sapply(p.seq, function(p) dtametasa.fc(IVD, p)$par)

## Print estimation

colnames(est1)<- paste0("p = ", p.seq)
kable(est1)
```

### Main function 2: dtametasa.rc

This function do not need to pre-specify the c contrast in the selection function. 

##### 1. Given a certain selection probability $p$, say, $p = 0.7$, we can get the estimation as follows.

```{r}
## Use default parameters setting
## Print parameters' estimates

(sa2 <- dtametasa.rc(IVD, p = 0.7))

## To get full results list

# str(sa2)
```

##### 2. Given a series of selection probabilities, say, $p = 1, 0.9, 0,8, ...,0.1$. 

Attention: **$p$ must greater than 0 and cannot equal to 0. ($p>0$).**

```{r}
## Set p vectors

p.seq <- seq(1, 0.1, -0.1)

## Get estimations for each p in p.seq vector

est2 <- sapply(p.seq, function(p) dtametasa.rc(IVD, p)$par)

## Print estimation

colnames(est2)<- paste0("p = ", p.seq)
kable(est2)
```

### Plot sROC

##### 1. Single sROC

```{r, fig.height=5, fig.width=10}
par(mfrow = c(1,2))

## This is the standard method: Reistma model
## Without taking publication bias (PB) into consideration

library(mada)
fit <- reitsma(IVD, correction.control = "all", method = "ml")
plot(sroc(fit, type = "naive"), type = "l", ylim = c(0,1), xlim = c(0,1), col = "red")
title("Reistma model from mada")

## Extact the estimation from Reistma model

par0 <- c(c(1,-1)*fit$coefficients, c(1,-1)*fit$Psi[c(4,3)])

## Our model that takes PB into consideration

# sa1 <- dtametasa.fc(IVD, p = 0.5)
# sa2 <- dtametasa.rc(IVD, p = 0.5)

## Plot ROC from Reistma model
sROC(par0, sroc.col = "red", spoint.col ="red")

## Add sROC
sROC(sa1, add = TRUE, sroc.col = "black", sroc.lty = 2, spoint.pch = 1, spoint.col = "black")
sROC(sa2, add = TRUE, sroc.col = "darkgray", sroc.lty = 2, spoint.col = "darkgray")

## Also works by using the extracted parameters, but attention the pars

par1 <- sa1$par[c(1,2,4,5)]
par2 <- sa2$par[c(1,2,4,5)]
sROC(par1, add = TRUE, sroc.col = "black", sroc.lty = 2, spoint.pch = 1, spoint.col = "black")
sROC(par2, add = TRUE, sroc.col = "darkgray", sroc.lty = 2, spoint.col = "darkgray")

## Calculate the data points (fpr, sens) of IVD

with(IVD, points(FP/(FP+TN), TP/(TP+FN), pch = 4, cex = 0.5))
legend("bottomright", c("Reistma", "dtametasa.fc", "dtametasa.rc", "IVD"), 
       col = c("red", "black", "darkgray", "black"), lty = c(1,2,2, 0), pch = c(19,1,19, 4))
title("When selection prob = 0.0.5")
par(mfrow = c(1,1))

```

##### 2. Multiple sROC

```{r, fig.height=5, fig.width=10}
## p vector and model

# p.seq <- seq(1, 0.1, -0.1)
# est1 <- sapply(p.seq, function(p) dtametasa.fc(IVD, p)$par)
# est2 <- sapply(p.seq, function(p) dtametasa.rc(IVD, p)$par)

## Plot multiple sROC
par(mfrow = c(1,2))
sROC.matrix(est1[c(1,2,4,5), ], legend = TRUE, p.vec = p.seq, legend.cex = 0.5)
sROC(par0, add = TRUE, sroc.col = "red")
title("dtametasa.fc")

sROC.matrix(est2[c(1,2,4,5), ], legend = TRUE, p.vec = p.seq, legend.cex = 0.5)
sROC(par0, add = TRUE, sroc.col = "red")
title("dtametasa.rc")
par(mfrow = c(1,1))


```

### Calculate sAUC and confident interval

Although sAUC has output together with the parameters in `dtametasa.fc` and `dtametasa.rc` functions. We can still calculate by using `sAUC()` function.

The confidence interval (CI) is calculated by parametric bootstrapping. 

To save computing time, we set bootstrapping times as 5 (`B = 5`).
Hence the results are not reliable.

<span style="color:red">**In real analysis, please set `B = 1000`.**</span>

If you donot hope to set the seed, please set `set.seed = NULL`

#### 1. Single sROC

```{r, fig.width=12, fig.height=6}

## Use parameter vector
par1 <- sa1$par
par2 <- sa2$par
sAUC(par1[c(1,2,4,5)])
sAUC(par2[c(1,2,4,5)])


par(mfrow = c(1,2))

sROC(sa1)
title("dtametasa.fc")
sROC(sa2)
title("dtametasa.rc")

par(mfrow = c(1,1))


```

#### 2. Single sROC with CI

```{r, fig.width=12, fig.height=6}

## Calculate Parametric Bootstrap CI
## B (Bootstrapping times) is suggested to be 1000. To save computing time, we use B = 10 to show the functionality.


par(mfrow = c(1,2))
sROC(sa1)
ci1 <- sAUC.ci(sa1, B=5, hide.progress = TRUE, set.seed=2021)
plot(ci1)
title("dtametasa.fc")

sROC(sa2)
ci2 <- sAUC.ci(sa2, B=5, hide.progress = TRUE, set.seed=2021)
plot(ci2)
title("dtametasa.rc")

par(mfrow = c(1,1))

```


#### 3. Multiple sAUC

```{r}

## Calculate Parametric Bootstrap CI

## B (Bootstrapping times) is suggested to be 1000. To save computing time, we use B = 5 to show the functionality.

p.seq <- seq(1, 0.1, -0.1)

sauc1 <- sapply(p.seq, function(p) {
  sa1 <- dtametasa.fc(IVD, p)
  sauc <- sAUC.ci(sa1, B=5, hide.progress = TRUE, set.seed=2021)
  c(sauc[[1]], sauc[[2]], sauc[[3]])
  })


sauc2 <- sapply(p.seq, function(p) {
  sa2 <- dtametasa.rc(IVD, p)
  sauc <- sAUC.ci(sa2, B=5, hide.progress = TRUE, set.seed=2021)
  c(sauc[[1]], sauc[[2]], sauc[[3]])
  })

colnames(sauc1)<- paste0("p = ", p.seq)
rownames(sauc1)<- c("sAUC", "CI.L", "CI.U")
kable(sauc1)

colnames(sauc2)<- paste0("p = ", p.seq)
rownames(sauc2)<- c("sAUC", "CI.L", "CI.U")
kable(sauc2)
```

#### 4. Plot sAUC

This is an example of how to plot sAUC and CI. In analysis, please set `B = 1000` and then reproduce the plots.


```{r, fig.height=5, fig.width=10}
par(mfrow = c(1,2))

## Use matplot to plot the sAUC and CI

matplot(t(sauc1), type = "b", lty = c(1,2,2), 
        pch = 19, col = c("black", "grey", "grey"),
        xlab = "p", ylab = "sAUC",
        ylim = c(0,1),
        xaxt = "n")
axis(1, at = 1:10, labels = p.seq)
title("dtametasa.fc")

matplot(t(sauc2), type = "b", lty = c(1,2,2), 
        pch = 19, col = c("black", "grey", "grey"),
        xlab = "p", ylab = "sAUC",
        ylim = c(0,1),
        xaxt = "n")
axis(1, at = 1:10, labels = p.seq)
title("dtametasa.rc")

par(mfrow = c(1,1))

```


