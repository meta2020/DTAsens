---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%")

options(knitr.kable.NA = '.', digits = 3)
```

# DTAsens

<!-- badges: start -->
<!-- badges: end -->

The goal of DTAsens is to conduct sensitivity analysis on DTA meta-analysis

## Installation

You can install the released version of DTAsens from [GitHub](https://github.com/meta2020/DTAsens) with:

``` r
devtools::install_git("meta2020/DTAsens")
```

## Example

This is an example which shows you how to solve a common problem:

```{r}
library(DTAsens)

data(IVD)
kable(head(IVD))

```

### Optim 1: dtasens1

For a certain selection probability, e.g., p = 0.7

```{r}
dtasens1(IVD, p = 0.7)

dtasens1(IVD, p = 0.7, 
         show.p.hat = TRUE, show.auc.all = TRUE, show.data = TRUE)
```

For a series of selection probabilities, e.g., p = 0.9, 0,8, ...,0.1


```{r}
p.seq <- seq(1, 0.1, -0.1)

estimates <- sapply(p.seq, 
                    function(p) dtasens1(IVD, p, 
                                         b.interval = c(0,2), 
                                         a.interval = c(-3,3), 
                                         a.root.extendInt = "downX")$par)

colnames(estimates)<- paste0("p = ", p.seq)
kable(estimates)
```

### Optim 2: dtasens2

For a certain selection probability, e.g., p = 0.7

```{r}

dtasens2(IVD, p = 0.7)

dtasens2(IVD, p = 0.7, 
         show.p.hat = TRUE, show.auc.all = TRUE, show.data = TRUE)

```

For a series of selection probabilities, e.g., p = 0.9, 0.8, ...,0.1


```{r}
p.seq <- seq(1, 0.1, -0.1)

estimates <- sapply(p.seq, 
                    function(p) dtasens1(IVD, p, 
                                         b.interval = c(0,2), 
                                         a.interval = c(-3,2), 
                                         a.root.extendInt = "downX")$par)

colnames(estimates)<- paste0("p = ", p.seq)
kable(estimates)
```

### Plot ROC

One ROC

```{r, fig.height=5, fig.width=10}
par(mfrow = c(1,2))

library(mada)
fit <- reitsma(IVD, correction.control = "single", method = "ml")
plot(fit)
title("Reistma model from mada")


par0 <- c(fit$coefficients*c(1,-1), c(1,-1)*sqrt(fit$Psi[c(1,4)]), fit$Psi[3]/prod(sqrt(fit$Psi[c(1,4)])))

par1 <- dtasens1(IVD, 0.7)$par
par2 <- dtasens2(IVD, 0.7)$par

sROC(par1, pch = 19, add.ci = FALSE)
sROC(par2, add = TRUE, col=2, pch = 19, add.ci = FALSE)
sROC(par0, add = TRUE, col=3, pch = 4, add.ci = FALSE)

with(IVD, points(FP/(FP+TN), TP/(TP+FN), pch = 4, cex = 0.5))
legend("bottomright", c("dtasens1", "dtasens2", "Reistma", "data"), col = c(1,2,3, 1), lty = c(1,1,1, 0), pch = c(19,19,4, 4))
title("When selection prob = 0.7")
par(mfrow = c(1,1))

```

A series of ROC

```{r, fig.height=5, fig.width=10}

p.seq <- seq(1, 0.1, -0.1)
estimates1 <- sapply(p.seq, 
                     function(p) dtasens1(IVD, p,
                                          b.interval = c(0,2),
                                          a.interval = c(-3,2))$par)
estimates2 <- sapply(p.seq, 
                     function(p) dtasens2(IVD, p,
                                          b.interval = c(0,2),
                                          a.interval = c(-3,2))$par)

par(mfrow = c(1,2))
mROC(par.matrix = estimates1)
sROC(par0, add = TRUE, col = 2, pch = 19, lty =3)
title("dtasens1")

mROC(par.matrix = estimates2, p.vec = p.seq)
sROC(par0, add = TRUE, col = 2, pch = 19, lty =3)
title("dtasens2")
par(mfrow = c(1,1))


```
